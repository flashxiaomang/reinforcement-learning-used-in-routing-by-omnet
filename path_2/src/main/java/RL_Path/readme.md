###源代码：
迷宫寻路，从源点到终点找到一条最优路径。
需要几个变量：（括号表示次要变量）
  初始化的时候需要的变量：map, Q, (start position, end position)
    map中，map[i][j]=1表示这个地方不能走，map[i][j]=0表示能走，map[i][j]=2表示在起点，map[i][j]=3表示到达终点
    map：
    [[1 0 2 1]
    [0 0 1 0]
    [0 1 0 3]]
    Q：
    [[0.01 0.01 0.01]
    [0.01 0.01 0.01]
    [0.01 0.01 0.01]]
    Q是记录该节点到其他节点的概率，设i点到j1, j2, j3有连接，假设i到j3的预期奖励最高，那么i到j3的概率越大（预期奖励越高，走这个路径的概率越大）
  程序运行中需要的其他变量：clone map
    clone map是把地图复制了一份，在寻路过程中，把走过的点设置为不可达（也就是走过的map[i][j]=0的点设置为map[i][j]=1），防止出现回路
程序运行逻辑：
  循环T次：
    循环N_max次：
      如果遇到墙或者到达终点，提前退出
      在pos点，根据Q表（Q表记录概率），往4个可能方向选择一个方向走（调用next函数和move函数）。把走过的路置为不可达点(map[i][j]=1)
        next函数：例如该点在pos点，Q[pos]有4个数，对应4个pos点可以走的方向，数字越大，该点往这个方向走的概率越大。
            返回值是下一步要走的方向0/1/2/3
        move函数：根据next函数的返回值，往下一个位置走，例如next=0, 往上走。
            返回值有3种可能性：如果走到终点，返回10000；如果撞墙或者走过已经走过的点，返回-10000；如果走到正常的点，返回下一个点的位置
      更新Q表：预期奖励越大，Q表对应的值越大，节点下次从这里走的概率越大。如果到达终点，如果当前路径超过了最优路径，更新最优路径。
      把下一个位置置为当前位置pos，开始下一轮循环
###网络路由代码：运行Application.java
需要几个变量：（括号表示次要变量）
  初始化的时候需要的变量：network_full, network_reachable_node, network_rewardOfLinks, Q_table, (start node, end node)
  network_full是一个辅助变量，实际不会用到。
  network_full：
  [[max_value 1 max_value]
  [1 max_value 1]
  [max_value 1 max_value]]
  network_reachable_node:
  [[1]
  [0 2]
  [1]]
  network_rewardOfLinks:之后有些走过的点会变成min_value
  [[-1]
  [-1 -1]
  [-1]]
把map替换为network_reachable_node和network_rewardOfLinks：map含有两个信息：每个点是可达/不可达/源点/终点；每个点可以走的位置（上下左右）
map中，每个点可以走的位置只能是上下左右，但在网络中，每个点可以到达的点需要一个额外的变量来存储，这个变量是network_reachable_node。
map中，每个点的值表示它是可达/不可达/源点/终点，在网络中，随着搜索的进行，我们需要把走过的点变成不可达点（这里是把走过的路径记为不可达路径），所以需要一个变量，这就是network_rewardOfLinks
Q替换为Q_table，记录每个点到其他可达点的概率
循环T次：
    循环N_max次：
      如果遇到不可达点（已经走过的路径）或到达终点，提前退出
      在pos点，根据Q表（Q表记录概率），往几个可能方向选择一个方向走（调用next函数和move函数）。把走过的路置为不可达点(network_rewardOfLinks[pos][next]=min_value)
        next函数：例如该点在pos点，Q[pos]有4个数，对应4个pos点可以走的方向，数字越大，该点往这个方向走的概率越大。
            返回值是下一步要走的方向0/1/2/3/...
        move函数：根据next函数的返回值，往下一个位置走，例如next=1, 找network_reachable_node[pos][1]，就是下一个点。
            返回值有3种可能性：如果走到终点，返回10000；如果走过已经走过的点，返回-10000；如果走到正常的点，返回下一个点的位置
      更新Q表：预期奖励越大，Q表对应的值越大，节点下次从这里走的概率越大。如果到达终点，如果当前路径超过了最优路径，更新最优路径。
      把下一个位置置为当前位置pos，开始下一轮循环